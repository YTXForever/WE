## 每日算法训练
   1.中间节点
   2.是否有环
   3.反转单链表
   4.回文链表
   5.合并有序链表
   6.删除倒数第K个节点

## 新生代垃圾收集器
    1. Serial 单线程 复制算法 STW 一般用在client模式下 
    2. ParNew 多线程 复制算法 STW  
    3. Parallel Scavenge 多线程 复制算法 STW 可以设置停顿时间 但是是以垃圾收集量为代价的 用在对停顿时间有要求的场景下和对吞吐量有要求的场景下
## 老年代垃圾收集器
    1.Serial Old 单线程 整理算法   STW
    2.Parallel Old 多线程 整理算法 STW
    3.CMS   多线程 清理算法(可以通过参数设置多久压缩一次内存)   
        初始标记：标记GCROOTS 直接可达的第一层 STW 非常快
        并发标记: GCROOTS Tracing 比较慢 但是没有STW
        重新标记：标记并发标记时的新晋对象Tracing  比较快 STW
        并发清理：清理算法 没有STW 比较慢 清理算法是不用STW的原因 
    
    CMS不能和Parallel Scavenge一起使用

## finalize
    1.对象第一次被标记不可达 并且finalize没有被执行过时 会加入F-Queue队列中 由一个优先级比较低的线程来执行 不保证finalize一定会被执行 可能存在执行一半的情况

## 引用
    1.强引用 Strong 什么情况下都不会被回收 即使OOM 普通引用都是强引用
    2.软引用 Soft 内存不足会回收  SoftReference 一般用于缓存
    3.弱引用 Weak  只要GC就会回收   WeakReference 一般用于缓存
    4.虚引用 Phantom  只要GC就会回收 PhantomReference 和ReferenceQueue配合使用 跟踪对象被回收的动态 不能拿到引用的对象
    5.ReferenceQueue保存的是引用 真实对象已经被回收 一种queue只保存一种对象 一般用来通知

## 缓存使用注意事项： 
    1、默认共识&常规操作： 
    1.1、默认共识：redis、memcache默认只是缓存，不需要落盘存储、不需要高可用(缓存出问题后会从数据库中获取)，申请缓存集群时和DBA沟通好）。特殊情况：缓存需要落盘，缓存需要高可用时，也一定要找DBA同学沟通好； 
    1.2、常规操作： 
        a、查询时，如果缓存中没有数据，则从数据库中获取数据，同时，设置到缓存中。如果缓存中有数据，直接返回缓存数据； 
        b、更新数据库后，淘汰缓存； 
    
    2、高可用&缓存命中率 
    2.1、基于第1点中“缓存出问题后会从数据库中获取到”，要评估缓存不可用时，或50%失效时(缓存命中率骤降时)，数据库的承受能力； 
    2.2、缓存扩、缩容时，考虑 既有的缓存组件 一致性hash算法是否有问题，有潜在导致缓存命中率骤降的坑； 
    
    3、一致性 
    3.1、更新数据库后，要淘汰缓存；
    是淘汰(delete)缓存，不是更新缓存，原因：
        a、减少并发更新导致数据不一致；
        b、更新缓存时，需要重新获取新数据，潜在获取新数据时，需要再写很多业务逻辑代码；
    3.2、给缓存设置过期时间，如果真有脏数据(缓存和数据库数据不一致了)，设置了缓存过期时间 等于 提供了数据最终一致性的可能；
    3.3、强一致性业务场景，可以考虑不走缓存，仅走数据库（如果走数据库就能保证一致性）
# 网络
## TCP/IP

1 | 协议 | 作用
--- | --- | ---
应用层 | 代表协议 Http/telnet/ftp |主要用来完成业务处理
传输层 |代表协议 Tcp/Udp         |主要用来控制网络包的发送，重传，确保连接的可靠性，流量控制，将数据分段
网络层 |代表协议  Ip             |主要用来寻址（网络地址->物理地址），网络包的路由，路由器工作在网络层
链路层 |代表协议  ARP            |主要在物理层面进行数据包的传输，交换机工作在数据链路层


## 传输控制协议TCP

1. 面向连接的、可靠的、基于字节流的传输层通信协议
2. 将应用层的数据流分割成报文段->ip层->目标节点的tcp层
3. TCP为了保证不丢失包，给数据包序号，序号也保证了目标节点的按序处理对方收到则发送ACK确认，未收到则重传。
4. 使用奇偶校验和函数来校验数据在传输过程中是否有错误，发送和接收时都校验。

## TCP的三次握手
*ACK 确认序号标志*
*SYN 同步序号，用于连接建立（握手）阶段*
1. 第一次：A发送SYN=1,seq=x,A的状态为SYN_SENT；
2. 第二次：B收到1的消息后，回复SYN=1，ACK=1，seq=y，ack=x+1，B的状态置为SYN_RCVD；
3. 第三次：A收到2消息后，回复ACK=1，seq=x+1，ack=y+1，A的状态置为ESTAB-LISHED；
4. B收到3消息，将B状态置为ESTAB-LISHED。

*注：* **三次握手是为了初始化x和y**
## SYN Flood问题
syn_flood就是利用大量的syn包，导致s端出现大量的syn_recv socket 占用大量的系统资源
设置tcp_syn_cookies后，当listen队列满了之后（ss -nltp查看) 系统便不会在新建socket syn_recv状态
而是将上一个syn,ack和时间戳信息计算出来一个seq发送，如果是攻击方不会回复，如果是正常请求，则会回复这个seq，s端或根据这个ack反向计算出是否是满足条件的请求，从而建立连接 
    

## TCP的四次挥手
*FIN finish标记，用于连接关闭（挥手）阶段*
1. 第一次：A发送FIN=1，seq=u，A状态置为FIN_WAIT_1（u是最后一次数据传输，最后一个字节序号）；
2. 第二次：B接收1消息，回复ACK=1，ack=u+1，seq=v，B状态置为CLOSE_WAIT；
3. A收到2消息，将B状态置为FIN_WAIT_2；
4. 这期间，B还可以继续向A传输数据；
5. 第三次：B发送FIN=1，ACK=1，seq=w（因4步骤有数据传输，消耗序列号），ack=u+1，B状态置为LAST_ACK；
6. 第四次：A收到5，回复ACK=1，seq=u+1，ack=w+1，将A置为TIME_WAIT；
7. B收到6消息，将B状态置为CLOSED；
8. A在6步骤基础上等待2MSL后，将状态置为CLOSED。

*注：* **四次挥手：因为全双工，AB各需要一次FIN和一次ACK**
## time_wait的作用
1. time_wait长2MSL 主动断开方收到last_ack后发送ack，成为此状态，是为了保证发送出去的ack能被对方收到，比如这个发出的包丢包了（1MSL），那么被动断开方将重传这个包(1MSL),这个时候主动断开方还应该在线并且能够给与回复
2. 如果不设置等待时间，发出的最后一个包发生了丢包的话，另一方会重传，如果这个时候这个socket已经被新连接重用了的话，会造成新包和旧包的混淆
    
## 服务器大量出现close_wait的原因
 1. 服务端忙于读写，没有及时处理对方的close
 2. 线程数过少
 
## tcp和udp的区别

区别 | tcp | udp 
---- | ---- | ----
连接 | 面向连接 | 无连接
可靠性|可靠：握手、错误重传|可能丢包
有序性|seq保证有序|无序
速度|拥塞控制可能会降低速度|只取决于网络状况和主机性能
量级 | 维护状态，header20字节| 轻量级，header8字节



## TCP的滑动窗口（流量控制与乱序重排）
- RTT和RTO：
RTT为发送一个数据包到收到ack所话费的时间
RTO是根据RTT计算出来的重传时间间隔
- 作用：
    1. 保证TCP的可靠性：在错误重传机制上保证顺序
    2. 保证TCP的流控特性:只能接受窗口大小的数据

## 在浏览器键入url，按下回车键后经历的流程
1. DNS解析：浏览器根据url逐层查询DNS服务器缓存，解析域名
对应的ip地址。
2. tcp建立连接（三次握手）
3. 发送http请求
4. 服务端处理请求并返回http报文
5. 结束tcp连接（四次挥手）
6. 渲染页面

*5和6 顺序可以改变*
*http1.1中设置请求头Connection:keep-alive，则一次TCP连接可以发送多次的HTTP请求*
## DNS解析顺序
1. 浏览器DNS缓存（内存中): 浏览器会按照一定频率缓存DNS记录
2. 本地DNS缓存(内存中): 如果浏览器缓存中找不到需要的DNS记录，
那就去操作系统找。
3. 本地HOSTS文件
4. 路由器DNS: 路由器自动获取DNS地址，也可以手动修改(路由器
DNS被篡改会造成域名劫持，你访问的网址都会被定位到同一个位置，
但是IP直接可以访问)
5. ISP的DNS服务器:  ISP(互联网服务提供商、联通电信移动)，
ISP有专门的DNS服务器应对DNS查询请求
6. 根服务器: ISP的DNS服务器还找不到的话，它就会向根服务器
发出请求，进行递归查询

## get请求与post请求的区别
层面 | GET | POST
--- | --- | ---
请求信息|放在URL|放在请求体中（安全性稍微高一点点）
长度限制|有限制（url本身无限制，浏览器做了限制）|无限制
数据库层面|符合幂等性和安全性|不符合
其他|可以被缓存、被存储|不可以

## keepalive 是否开启服务端控制还是客户端控制？ 
keepalive可以由双方共同控制，需要双方都开启才能生效，HTTP1.1客户
端默认开启，客户端想关闭可以通过设置Connection: Close，服务端同
样想关闭可以设置Connection: Close。双方哪方先收到Connection: Close 
则由收到方关闭（前提是双方的实现都支持，比如telnet就不支持）

## keepalive时间一到，是由客户端主动关闭还是服务端主动关闭？ 
哪方的时间短，由哪一方来关闭，除非双方的实现有更明确的协议、 

## cookie和session的区别
方面 | cookie | session
---- | ---- | ----
存储位置|浏览器|服务器
安全性 | 较低 | 较高
默认的有效路径|当前目录及其子目录|整站有效
数据传输量|限制4k，最多20个|无限制
访问权限|不区分路径，整站有效|可以设置路径

## session什么时候被创建
- 某server端程序(如Servlet)调用HttpServletRequest.getSession(true)
时才会被创建.
- 服务器停止或者重启时，原则上session会清除，但是tomcat在对session进行
序列化，写入本地


## http tcp socket的关系
- HTTP基于TCP；
Socket是TCP或者UDP的实践，规范数据传输过程客户端和服务端的数据读写，
可以把socket看作是网络上的文件，网络连接的两端各维护一个这样的文件，
用于传输过程中的数据的读写。
- socket是对TCP/IP协议的封装和应用
- 通常情况下socket连接就是tcp连接，tcp连接是全双工的，所以客户端
与服务端可以相互发送数据；但是http连接是基于"请求-响应"机制的，
服务端不可以主动向客户端发送数据。
- socket - > 门面模式

## 长连接&短连接
 - 长连接：即时通讯、数据库、推送服务 
 - 短连接：web提供对http服务
## 分布式Session的几种实现方式
https://blog.csdn.net/u014352080/article/details/51764311/









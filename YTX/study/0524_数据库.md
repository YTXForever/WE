# 数据库 https://www.cnblogs.com/tgycoder/p/5410537.html
## 数据库范式
*一般来说满足第三范式*
- 第一范式：表中的每一行，有且仅有唯一的行值，不存在两行数据一模一样；
对于某一行，其每一列都有且仅有唯一的值，并且不可拆分
- 第二范式：
    1. 满足第一范式
    2. 一是表必须有一个主键
    3. 非主键完全依赖于整个主键，而不能只依赖于主键的一部分
- 第三范式：
    1. 满足第二范式
    2. 不能有非主属性的传递函数依赖：
    选课表（学号、课程名、学分）中课程名依赖于学号，学分依赖于课程名，
    这就出现了传递依赖，不满足第三范式。
- BC范式：
- 第四范式：
- 第五范式：
## 数据库组成
- 存储（文件系统）
- 程序实例（存储管理、缓存机制、SQL解析、日志管理、权限划分、容灾机制、索引管理、锁关管理）
## 索引
- 为什么要使用索引：避免全表扫描，提升查找速度。
- 什么样的信息能够成为索引：主键、唯一键等有区分度的数据。
- 索引的数据结构
    1. 二叉查找树逆行二分查找（或者平衡二叉树、红黑树）
    2. B-tree
    3. B+-tree（主流索引数据结构）
        1. 叶子节点存储数据或者数据对应地址或者主键，非叶子节点仅用来做索引；
        对于非叶子节点，一个磁盘块能存储的关键字更多，从而树的层级更少，磁盘i/o次数更少；
        
        2. 所有叶子节点均有一个连接指向下一个叶子节点，方便在叶子节点做范围统计。

    4. hash结构索引 
        1. 效率高
        2. 仅能满足"="，"in"，不能范围查询
        3. 不能利用部分索引
        4. 无法避免数据库的排序操作（hash无法确定原值的大小）
        5. 不能避免表扫描
        6. 大量hash值相等的情况下，效率低
    5. Bitmap --（小众）
    
 ### B+-tree更适合用来做索引
 - 磁盘读写代价低（非叶子节点只存索引，可以存更多节点，一次性读入内存的需要查找的关键字就越多，需要读取的次数就越少）
 - 查询效率稳定（必须遍历到叶子节点）
 - 有利于对数据库的扫描（遍历叶子节点链表）
 
 ### 密集索引和稀疏索引
 - myisam：只有稀疏索引；索引和数据分开。
 - innoDB：有且仅有一个密集索引，密集索引中包含数据信息.
    - 密集索引选取：主键 > 第一个非空索引 > innodDB生成一个隐藏主键；
    - innoDB的稀疏索引需要两次遍历索引（一次稀疏索引+一次主键索引）
 
 ### 索引相关问题
 #### 一 如何定位和优化慢查询sql
 1. 根据慢日志定位慢查询sql
    - show variables like '%quer%',
    关注结果集中的"show_query_log"(是否开启慢日志记录，可设置开关)、"show_query_log_file"（慢日志文件）、"long_query_time"（慢日志判断时间，可修改时间）；
    - show status like '%slow_queries%':慢查询数量；
    
 2. 使用explain工具分析sql
    - explain结果：type
    
    |type | desc|
    |-----| --- |
    |**ALL**  | 全表扫描（如果是慢查询sql，需要考虑优化）|
    |**index**|索引全扫描（如果是慢查询sql，需要考虑优化）|
    |range|索引范围扫描，常用语<,<=,>=,between等操作|
    |ref|使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中|
    |eq_ref|类似ref，区别在于使用的是唯一索引，使用主键的关联查询|
    |const/system|单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询|
    |null|MySQL不访问任何表或索引，直接返回结果|
    - explain结果：Extra
    
    |Extra|desc|
    |-----|----|
    |using index|使用了覆盖索引，避免访问了表的数据行，效率不错！|
    |using where」|服务器在存储引擎收到行后将进行过滤。有些where中的条件会有属于索引的列，当它读取使用索引的时候，就会被过滤，所以会出现有些where语句并没有在extra列中出现using where这么一个说明|
    |**using temporary**|（效率低）意味着对查询结果进行排序的时候使用了一张临时表|
    |**using filesort**|（效率低）会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取|
    
    *key_len的计算规则如下：*
    
    - 如果列可以为空,则在数据类型占用字节的基础上加1,如int型,不能为空key_len为4,可以为空key_len为5
    - 如果列是变长的,则在数据列所占字节的基数上再加2,如varbinary(10),不能为空,则key_len为10  + 2 ,可以为空则key_len为10+2+1
    - 如果是字符型,则还需要考虑字符集,如某列的定义是varchar(10),且是utf8,不能为空,则key_len为10 * 3 + 2,可以为空则key_len为10*3+2+1

 3. 修改sql使其尽量走索引
 
 #### 二 联合索引的最左匹配原则的成因
 - 索引（a,b,c），条件b=2，c=3，a=1，走联合所以，abc都走（mysql引擎给做了优化）
 - 索引（a,b,c），条件a=1，b >2,c=3,走联合索引，但是只有a和b走索引，c不走。
 - 索引（a,b,c），条件a=1,c=3,走联合索引，但是只有a走索引，c不走。
  
 #### 三 索引越多越好吗？当然是NO
 - 数据量小不需要
 - 数据变更需要维护索引
 - 更多索引占用更多空间
 
 ## 锁
 ### myisam与innoDB关于锁的区别
 - myisam：默认表级锁，不支持行级锁；
 - innoDB：默认行级锁，支持表级锁，sql用到索引时，使用行级锁或者gap锁（走普通非唯一索引时走gap锁），
 当sql不走索引时，使用表级锁。
 ### myisam与innoDB的区别
 
 区别|myisam|innoDB
 ---|---|---
 锁 |默认表级锁，不支持行级锁|默认行级锁，支持表级锁
 事务|不支持|支持
 索引|稀疏索引|有且仅有一个聚集索引
 data数据存放位置|与索引分开两个文件存储|存放在聚集索引大叶子节点
 效率|增删改效率差（表级锁导致），查询效率高|增删改查效率都挺高
 
 ### 数据库事务的特性
 - A:原子性（Atomic）
 - C:一致性（Consistency）
 - **I:隔离性（Isolation）**
 - D:持久性（Durability）
 
 ### 事务隔离级别
 隔离级别 | 解决问题 | 出现问题 |
 ------- | ------- | ------ |
 读未提交（read uncommitted） | 更新丢失 | 脏读 |
 读已提交（read committed） | 脏读 | 不可重复读 |
 可重复读（repeatable read） |不可重复读|幻读 |
 可序列化（serializable） | 幻读 | ～～ |
 
 *（这里持疑）事务隔离级别实现：
 https://www.jianshu.com/p/563612576e6e*
 
 - 读未提交：读操作不加任何锁并且显式加lock in share mode也不生效，
 写操作加排他锁,select ... for update生效；
 
 - 读已提交：读操作使用伪MVCC机制,lock in share mode生效，
 写操作加排他锁,select ... for update生效，
 **同一事务中多次读，会生成多次快照，所以读取读的是最新数据；**
 
 - 可重复读：读操作使用伪MVCC机制，,lock in share mode生效，
 写操作加排他锁，,select ... for update生效，
 **但是一次事务中只在第一次select时生成快照，
 后续的查询都是在这个版本上进行，从而实现了可重复读；**
 
 - 可序列化：读会自动将所有不使用自动提交的普通select转化为
 select ... lock in share mode执行，（如果开启了自动提交且没有使用显式start transaction；，
 普通的select不会加lock in share mode,即使用的是快照读）
 即针对同一数据的所有读写都变成互斥的了；
        
*innoDB在可重复读隔离级别怎么做到避免幻读？*
- 表象：快照读（不加锁读非阻塞读：select，不加锁读条件是串行化隔离级别之下），
    1. 在串行化隔离级别下，快照读退化为当前读；
    2. 在可重复读级别下，快照读读取的是上一次快照读创建的快照中的数据，所以快照创建的时机决定了快照读读取的版本；
    3. 在读已提交级别下，每次快照读都会创建新读快照，所以读到的都是已提交的最新数据。
- 内在：next-key锁（行级锁+gap锁）
    1. 行锁
    2. gap锁：在RC及RC以下隔离级别下是没有的，所以RC及RC以下隔离级别会出现幻读。RR及串行化级别不会出现幻读。
 
 *在RR隔离级别，当前读使用主键索引或者唯一索引 会用gap锁吗？*
 - 如果where全部命中，则不会使用gap锁，如 id in（1,2)，id
 为1和2的数据都存在，则不会加gap锁，因为即使事务B增数据，新增的数据也会在事务A当前读的数据范围之外。
 - 对非主键唯一索引加锁时，需要同时对其对应对主键索引加锁；
 - 如果where条件全部没有命中或者部分命中，则加gap锁；
 - 使用非唯一锁时，会用gap锁。
 
 
 
 
 
  
 
 
 
 








## 引用计数法
为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。

## 可达性分析法
将一系列GC Roots作为初始的存活对象合集(live set)，然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记(mark)。最终，未被探索到的对象便是死亡的，是可以回收的。

## stop the world
停止其他非垃圾回收线程的工作，直到完成垃圾回收。

## 安全点
执行代码时，如果Java虚拟机的堆栈不会发生改变，就代表着这段代码可以作为一个安全点。

# 垃圾回收方式
## 标记-清除
把死亡对象所占据的内存标记为空闲内存。  
缺点：①会造成内存碎片；②分配效率较低；

## 标记-整理
把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。
缺点：性能开销较大

## 复制
把内存区域分为两等分，每次只使用其中一个内存区域来分配内存。当发生垃圾回收时，把存活的对象复制到另外一个内存区域，把垃圾对象所占据的内存标记为空闲内存。
缺点：使用率较低

------
### 什么是GC Roots?
>由堆外指向堆内的引用。
>1. Java方法栈桢中的局部变量；
>2. 已加载类的静态变量；
>3. JNI handles；
>4. 已启动且未停止的Java线程。  

### 如何知道一段代码是安全点？
>当然是通过检测，但是如何检测，没记住



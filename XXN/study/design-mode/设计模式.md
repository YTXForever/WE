# 设计模式

设计模式主要分为三种：创建型、行为型、结构型

## 1.创建型设计模式

### 1.单例模式

单例模式特点：
　　1、单例类只能有一个实例。
　　2、单例类必须自己创建自己的唯一实例。
　　3、单例类必须给所有其他对象提供这一实例。

单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。

#### 1.1饿汉模式

```java
public class UserService{
    private static UserService service = new UserService();
    private UserService(){}
    public static UserService getInstance(){
        return service;
    }

}
```

#### 1.2懒汉模式

```java
public class UserService{
    private static volatile UserService service = null;
    private UserService(){}
    public static UserService getInstance(){
        if(service==null){
            synchronized (UserService.class) {
			   service = new UserService();
		    }
        }
        return service;
    }

}
```

#### 1.3内部类

```java
public class UserService{
    private UserService(){}
    private class UserServiceHolder{
        private static UserService service = new UserService();
    }
    public static UserService getInstance(){
        return UserServiceHolder.service;
    }

}
```

### 2.工厂模式

提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例

```java
/**接口类*/
public interface IMessageService{
    public void sendMsg(String text);
}
/**发短信*/
public class ShortMessageService implements IMessageService{
    public void sendMsg(String text){
        System.out.println("发短信");
    }
}
/**发邮件*/
public class MailMessageService implements IMessageService{
    public void sendMsg(String text){
        System.out.println("发邮件");
    }
}
/**简单工厂类*/
public class MessageFactory{
    public IMessageService getInstance(int type){
        switch(type):
          1:return new ShortMessageService();
          2:return new MailMessageService();
        default:return new MailMessageService();
    }
}
```

### 3.抽象工厂

抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类

![img](http://hi.csdn.net/attachment/201203/16/0_1331859200u1VV.gif)
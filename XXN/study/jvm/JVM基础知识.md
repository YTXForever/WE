# JVM基础知识

1. 使用-XX:ParallelGCThreads=设置并行垃圾回收的线程数。此值可以设置与机器处理器数量相等。
   此收集器可以进行如下配置： 最大垃圾回收暂停:指定垃圾回收时的最长暂停时间，通过-XX:MaxGCPauseMillis=指定。为毫秒.如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。
   吞吐量:吞吐量为垃圾回收时间与非垃圾回收时间的比值，通过-XX:GCTimeRatio=来设定，公式为1/（1+N）。例如，-XX:GCTimeRatio=19时，表示5%的时间用于垃圾回收。默认情况为99，即1%的时间用于垃圾回收。
   可以保证大部分工作都并发进行（应用不停止），垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用。使用-XX:+UseConcMarkSweepGC打开。
   并 发收集器主要减少年老代的暂停时间，他在应用不停止的情况下使用独立的垃圾回收线程，跟踪可达对象。在每个年老代垃圾回收周期中，在收集初期并发收集器会 对整个应用进行简短的暂停，在收集中还会再暂停一次。第二次暂停会比第一次稍长，在此过程中多个线程同时进行垃圾回收工作。
   并发收集器使用处理器换来短暂的停顿时间。在一个N个处理器的系统上，并发收集部分使用K/N个可用处理器进行回收，一般情况下1<=K<=N/4
   在只有一个处理器的主机上使用并发收集器，设置为incremental mode模式也可获得较短的停顿时间。
   浮动垃圾：由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了“Floating Garbage”，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，并发收集器一般需要20%的预留空间用于这些浮动垃圾。
   Concurrent Mode Failure：并发收集器在应用运行时进行收集，所以需要保证堆在垃圾回收的这段时间有足够的空间供程序使用，否则，垃圾回收还未完成，堆空间先满了。这种情况下将会发生“并发模式失败”，此时整个应用将会暂停，进行垃圾回收。
   启动并发收集器：因为并发收集在应用运行时进行收集，所以必须保证收集完成之前有足够的内存空间供程序使用，否则会出现“Concurrent Mode Failure”。通过设置-XX:CMSInitiatingOccupancyFraction=指定还有多少剩余堆时开始执行并发收集
   数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。
   “对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。
   应用响应时间可能较长
   “对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。
   JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统 下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。
   典型设置：
   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k
   -Xmx3550m：设置JVM最大可用内存为3550M。
   -Xms3550m：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
   -Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
   -Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。


JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。

java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20
-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。
-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC
-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。
java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100
-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。
java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy
-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。



java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
-XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。
java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片

-Xms:初始堆大小
-Xmx:最大堆大小
-XX:NewSize=n:设置年轻代大小
-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
-XX:MaxPermSize=n:设置持久代大小

-XX:+UseSerialGC:设置串行收集器
-XX:+UseParallelGC:设置并行收集器
-XX:+UseParalledlOldGC:设置并行年老代收集器
-XX:+UseConcMarkSweepGC:设置并发收集器

-XX:+PrintGC
-XX:+Printetails
-XX:+PrintGCTimeStamps
-Xloggc:filename

-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)

-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
并发垃圾收集信息
持久代并发收集次数
传统GC信息
花在年轻代和年老代回收上的时间比例
减少年轻代和年老代花费的时间，一般会提高应用的效率
吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。



## 2.内存模型(http://www.importnew.com/31126.html)

a,b,c线程私有，d,e线程共享

### 2.1   a)虚拟栈

  虚拟机栈由一个个栈帧组成。每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法出口信息。局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

局部变量表：包含了方法执行中所有变量。操作数栈:入栈、出栈、复制、交换、产生消费变量

  会出现两种异常:
  StackOverFlowError: 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
  										局部变量表内容越多，栈帧越大，栈深度越小
  										调整每个线程虚拟栈大小：   -Xss2m
  OutOfMemoryError: 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。
  每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。



![1561993685442](C:\Users\hy900\AppData\Roaming\Typora\typora-user-images\1561993685442.png)



**为什么递归可能引发stack overflow?**

虚拟机栈由一个个栈帧组成。每调用一次方法都会生成一次栈帧，将对应的栈帧压入虚拟机栈中，方法完毕后，会将栈帧出栈。由于递归函数是自调用，保存当前栈帧状态放入虚拟机栈中，上下文切换的时候，会切换最新方法栈帧中。由于虚拟机栈帧深度一定，每次递归都会放入虚拟机栈中，如果递归次数多，则会引起stack overflow。



### 2.2 b)本地方法栈

  虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务

### 2,3 c)程序计数器

   d1:字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   d2:在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
   程序计数器是唯不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 2.4 d)堆

   Java 堆是所有线程共享的一块内存区域。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
   jdk1.7 新生代、老年代、永久代
   jdk1.8 元空间metaspace取代永久代。元空间使用本地物理内存，不使用堆内存

### 2.5 e)<jdk7方法区 ,>=jdk8  元空间

  它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
  常量类型：深入了解虚拟机第六章  看
  运行时常量池：
  class常量池：4个字节(Magic Num)表示该文件是否被JVM接受，4个字节记录版本号，后面是存放常量的常量池；有一个计数器

#### 2.5.1方法区与元空间区别

元空间使用本地内存；永久待使用的是jvm内存；优点:不会出现  永久代内存溢出

对比优势:

字符串常量池，有性能问题

类和方法大小难以确定大小

永久代大小会给GC带来不稳定性。

### 2.6java内存中堆和栈的区别

静态存储:编译时确定每个数据目标在运行期间的存储空间需求(类似常量)

栈式存储:编译时不确定，运行时模块入口前才能确定

堆式:编译或运行模块入口前都不能确定的，动态分配(比如变长字符串)

引用对象、数组时，栈里定义变量保存指向对象、数组的首地址

堆：需要GC，栈不需要

栈空间<堆空间

栈空间：静态分配+动态分配；堆：动态分配

### 2.7intern()

jdk6：当调用该方法，如果字符串常量池存在这个字符串对象，那么返回该引用。否则将此字符串添加到常量池中，返回引用

> jdk6:当调用该方法，如果字符串常量池存在这个字符串对象，那么返回该引用。否则将此字符串对象存在堆中，那么将堆中此**对象的引用**放入常量池中，并返回该引用；如果堆中不存在，则在池中创建并返回引用
>
> > > > \>jdk6      false true
>
> ```java
> public static void main(String[] args) {
> 	String s1 = new String("a");
> 	s1.intern();
> 	String s2 = "a";
> 	System.out.println(s2==s1);
> 	String s3 = new String("a")+new String("a");
> 	s3.intern();
> 	String s4 = "aa";
> 	System.out.println(s3==s4);
> }
> ```

## 3.对象创建过程

  3.1类加载检查
  	 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程
  3.2分配内存

     从heap中分配空间给新生对象。分配方式有 “指针碰撞” 和 “空闲列表” 两种
     指针碰撞：可用内存连续。 维护一个临界指针，通过移动指针，分配内存。GC方法:标记-整理   GC收集器： Serial，ParNew。
     空闲列表：内存不连续。JVM维护一个列表，存储空闲内存空间地址。找到足够大的地方，分配给新生对象。GC方法：标记清除  GC收集器：CMS
     
     如何保证内存分配线程安全？
     a)CAS+重试
     b)为每一个线程预先在 Eden 区分配一块内存。JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。
  3.3初始化0值
  3.4设置对象头
  3.5执行init

## 4.对象在堆中布局

  4.1对象头+实际数据+位补充
  第一部分用于存储对象自身的自身运行时数据（哈希码、GC分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例
  Hotspot JVM要求一般对象是8字节的整数倍



## 5.四种引用

	a)强引用:
	代码中普遍存在的，A a = new A();只要强引用存在，垃圾收集器则不会回收掉被引用的对象
	b)软引用
	SoftReference:用来描述非必需对象；在将要发生内存溢出之前，会将该对象列入回收范围内进行GC;GC后空间如果仍然不足，则继续报内存溢出
	c)弱引用
	WeakReference:被弱引用关联的对象只能存活至下一次GC之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用的对象
	d)虚引用
	PhantomReference:作用是当这个对象被收集器收集时会受到一个系统通知。

## 6.可达法：可做GC Root

  a)虚拟机栈中引用的对象
  b)方法区中类静态属性引用的对象
  c)方法区中常量引用的对象
  d)本地方法栈中引用的对象

  e)活跃线程引用对象

  不可达对象不一定会被GC；当发现不可达时，会被标记一次；此时当该对象没有重写finalize()方法或JVM已经调用过finalize();则视为没有必要执行。

## 7.new gen对象什么时候会晋升到old gen中？

		a)多次minor gc后依然存活的对象，在存活年龄超过MaxTenuringThreshold阈值时会晋升到old gen中。
		b)在创建大对象/数组时，如果设置了PretenureSizeThreshold，超过大小的对象会直接在old gen中分配内存。
		c)当新生代内存不够时，对象会直接在old gen中分配内存
  什么时候会出现old gen空间不足（old gen空间不足时，会触发full gc）？HandlePromotionFailure-------------------------------------待补充
		a)创建大对象，大数组时，如果设置了PretenureSizeThreshold，超过阈值会直接在old gen中分配内存，此时可能会出现old gen内存不足。
		b)minor gc完成后，可能会有对象满足了MaxTenuringThreshold设置的晋升年龄，需要晋升到old gen，此时可能会出现old gen内存不足。
  	c)如果设置了新生代收集担保机制即HandlePromotionFailure关闭，则会在old gen中预留edu+survivor大小的空间作为担保，如果minor gc时，

#### 7.1JVM参数

java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
-XX:NewRatio=4:设置年老代（包括Eden和两个Survivor区）与年轻代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
-XX:MaxPermSize=16m:设置持久代大小为16m。
-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。

## 8.什么时候会进行FULL GC

老年代空间不足

永久代空间不足(<=1.7)

CMS出现promotion failed,concurrent mode failed

minor GC 晋升到老年代的平均大小>老年代剩余空间大小 (垃圾回收的时候会检查上一次minor gc升级到老年代的大小，比如6M，那么这次回收中如果老年代剩余空间<6M，触发full gc)

system.gc()

## 8.垃圾回收算法

​		a)计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
​		b)标记-清除法:标记所有需要回收的对象，最后统一清除待回收对象。缺点：效率低下，容易产生大量的内存碎片，导致大对象可能找不到足够的空间，从而不得不提前触发GC
​		c)复制算法：将内存分为两半。将存活的对象全部移动到其中一半，清除另一半的内存空间。优点：不会产生内存碎片，缺点内存使用率低。新生代算法
​		d)标记整理：老年代GC算法。标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。
​		标记-整理算法相比标记-清除算法的优点是内存被整理以后不会产生大量不连续内存碎片问题。复制算法在对象存活率高的情况下就要执行较多的复制操作，效率将会变低，而在对象存活率高的情况下使用标记-整理算法效率会大大提高。
​		e)分代收集法：分为新生代、老年代；当对象存活的时间长，经过了几次youngGC仍然存活(计数器)，将该对象移入老年代中；如果该对象是大对象，新生代内存不足以创建，则直接在老年代中创建。对于新生代的回收:minor GC。新生代采用标记复制-清除法。新生代分为三个区：Eden,survivor From,Survivor to,三个区；其中Survivor from和Survivor to总有一个区域是空白，只有Eden和其中一个Survivor总共90%的新生代容量用于为新创建的对象分配内存，只有10%的Survivor内存浪费，当新生代内存空间不足需要进行垃圾回收时，仍然存活的对象被复制到空白的Survivor内存区域中，Eden和非空白的Survivor进行标记-清理回收，两个Survivor区域是轮换的。老年代标记-整理垃圾回收算法，回收：major GC/Full GC.
​		永久代：是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。永久代垃圾回收比较少，效率也比较低，但是也必须进行垃圾回收，否则会永久代内存不够用时仍然会抛出OutOfMemoryError异常。永久代也使用标记-整理算法进行垃圾回收，java虚拟机参数-XX:PermSize和-XX:MaxPermSize可以设置永久代的初始大小和最大容量。

## 8.GC垃圾收集器

    新生代垃圾收集器
    a)Serial收集器：单线程执行。需要暂停用户工作线程，新生代。Serial Old是老年代回收的垃圾收集器，使用标记-整理算法。
    b)Parnew收集器：多线程新生代垃圾收集器。-XX:ParallelGCThreads控制垃圾回收线程数量。默认开启的收集线程数与CPU的数量相同
    c)Parallel Scavenge收集器：采用复制算法的多线程新生代垃圾回收器，关注的目标是吞吐量。CPU用于运行用户代码的时间与CPU总消耗时间的比值。jvm sever模式年轻代垃圾回收  -XX:UseParallelGC
    老年代收集器
    d)CMS收集器：标记清除算法
        过程分为：初始标记(stop-whole-world 从root标记)、并发标记(用户线程、标记线程同步存在)、并发预清理(查询并发标记中年轻代升级到老年代的对象),重新标记(暂停虚拟机，扫描CMS中剩余对象)、并发清除(用户线程、清除线程同时存在),并发重置(重置CMS收集器数据结构)。CMS提供一个XX:+UseCMSCompactAtFullCollection收集开关参数(默认开启)用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的。XX:CMSFullGCsBeforeCompaction参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。
        默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小。在并发清理的过程中，用户线程仍在工作，所以无法清理该过程中用户线程留下的垃圾。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。
    e)G1收集器(jdk1.9默认垃圾收集器)
        G1收集器是一款面向服务端应用的垃圾收集器。G1回收范围是整个heap内存。将heap内存均分为多个region。可以设置region个数，最多设置2048个。region可能是eden,survior,old区。每个region维护一个rememberedset,内部存储该region内部引用及与其他region间的引用。从而避免扫描全堆。
        G1具备如下特点：
            并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。
            分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。
            空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。
            可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
            在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。
## 9.JVM类加载机制

###    9.1装载：查找和导入Class文件；

      需要做
      classloader
      a)通过类的全限定名称获取类的二进制字节流，加载到内存中。运行数据转为方法区数据。生成class
###    9.2链接：

​     把类的二进制数据合并到JRE中；

​        (a)校验：被加载的类是否满足虚拟机约束条件
​        (b)准备：给类的静态变量分配存储空间；
​        (c)解析：类在没有被加载到虚拟机的时候，是不清楚自己静态成员、方法等信息。运行期间，每当遇见一个引用，编译器会生成一个符号引用。将符号引用转成直接引用；如果符号引用指向未加载的类，触发这个类加载

###    9.3初始化：

   对类的静态变量赋值，执行<clinit>方法(静态代码块,加锁，保证只执行一次)

###    9.4类加载时机

​       a）虚拟机启动，初始化用户指定类

​       b) new指令

​       c）调用静态方法，初始化静态方法所在类

​       d)调用静态变量，初始化静态变量所在类

​       e)子类初始化触发父类初始化

​       g)实现接口default方法，会触发该接口初始化

​       h）API反射调用

​       i)初次调用MethodHandle实例，初始化MethodHandle指向方法所在类

10.双亲委派机制
   10.1 boostrap加载器 ，加载lib/rt.jar
   10.2 extension加载器，加载lib/ext/路径下jar包，可以java.ext.dirs指定路径
   10.3 application所使用的jar包



## 10.命令

  9.1 jinfo pid可以查看pid的jvm参数； jinfo pid -flag
  9.2 jmap
  9.3 jstack
  jstat -gcutil pid 1s每秒刷新gc情况

## 11.class.forname与loadclass区别

class.forname得到的是已经初始化好的class

classloader获取的class是还没有链接的
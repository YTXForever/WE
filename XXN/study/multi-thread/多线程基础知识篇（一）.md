# 多线程基础知识篇（一）

## 1.线程与进程的区别

进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。

线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

**进程线程的区别：**

- 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
- 资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。

　　　　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

　　　　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

- 执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 线程是处理器调度的基本单位，但是进程不是。
- 两者均可并发执行。

## 2.线程创建的形式

   a)extends Thread

   b)implements Runnable

## 3.interrupte(),isinterrupte()，interrupted()

   interrupte()方法，线程中断，给线程一个中断信号。如果当前线程正在中断，会抛securityException；如果当前进程正在进行io操作，那么通道会被关闭，throw ClosedByInterruptException，设置为中断状态；如果当前进程正在被Selector阻塞，设置中断状态；

如果当前进程被wait，sleep，join阻塞，中断状态被清空，throw InterruptedException

interrupted():静态方法，返回当前进程的中断状态

isinterrupte():成员方法，返回该对象的中断状态

## 4.线程四种状态

   a)新建b)可运行c)运行d)阻塞e)死亡

## 5.wait,notify,notifyAll(),suspend,resume,join,yeild

   wait,notify,notifyAll:属于Object类方法；wait是等待对象的notify，阻塞期间，释放锁。notifyAll唤醒。notify方法，是唤醒等待队列里面随机一个线程。notifyAll唤醒等待队列中所有等待该对象的线程

suspend，resume是作用于Thread类，阻塞，继续。不推荐使用，因为在阻塞过程中不释放锁。

​    join：阻塞当前进程，等待新的进程加入。eg:  main(){t1.join();}主线程等待t1线程执行完毕，共同执行下面代码

​    yield:让出CPU；仍会参加CPU资源争夺

## 6.volatile关键字

​    每个线程都有一份本地的缓存threadlocal;volatile关键字修饰变量，会使该变量在本地缓存中失效，每次都会去主存(物理内存)中刷新数值；如果对该值进行写操作，那么会将修改后的数值刷新到物理内存中。

​    防止指令重排

## 7.synchronized关键字

  执行加锁对象，直接作用于实例方法，也可以作用于静态方法。

## 8.线程池

有4中线程池

 Executors.newFixedThreadPool(int threadNum)返回一个固定数量的线程池。

 Executors.newSingleThreadExecutor()返回一个只有一个线程的线程池

Executors.newCachedThreadPool()返回一个根据实际情况调整线程数量的线程池

Executors.newSingleThreadScheduleExecutor()定时执行的任务池

Executors.newScheduledThreadPool(int size)返回ScheduledExecutorService，可以指定数量

以上内部实现都是new ThreadPoolExecutor(xx,xx,xx)方法，获取到不同的线程池。

public ThreadPoolExecutor(int corePoolSize,

​                              int maximumPoolSize,

​                              long keepAliveTime,

​                              TimeUnit unit,

​                              BlockingQueue<Runnable> workQueue,

​                              ThreadFactory threadFactory,

​                              RejectedExecutionHandler handler) 

ThreadPoolExecutor最后一个参数，当任务数量超过系统承载时，handler是拒绝策略。JDK内置策略：AbortPolicy:该策略默认抛异常，阻止系统工作(默认使用)

CallerRunsPolicy：如果连接池未关闭，该策略一直在调用者线程中运行当前丢弃的任务

DiscardOldestPolicy:抛弃最老的请求

DiscardPolicy:放弃无法处理的任务

ThreadPoolExecutor



ThreadFactory用来创建线程，可以自定义需设置线程名称、优先级、设置守护线程等。

## 9.Fork/Join框架

​       T  RecursiveTask<T>有返回值，RecursiveAction没有返回值

fork()提交到fork线程池去执行,join()等待所有线程执行结束，继续执行

​        eg:

​     

```
 ForkJoinTest extends  RecursiveTask<Long>{

   @override

   public long compute(){

                
    }

}
```



